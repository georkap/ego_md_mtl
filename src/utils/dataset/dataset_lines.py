import osfrom pathlib import Path, PureWindowsPathimport numpy as npclass DataLine(object):    def __init__(self, row):        self.data = row.strip().split(' ')    @property    def data_path(self):        return str(Path(PureWindowsPath(self.data[0])))class EPICDataLine(DataLine):    def __init__(self, row):        super(EPICDataLine, self).__init__(row)    @property    def num_frames(self):  # sto palio format ayto einai to start_frame        return int(self.data[1])    @property    def label_verb(self):        return int(self.data[2])    @property    def label_noun(self):        return int(self.data[3])    @property    def uid(self):        return int(self.data[4] if len(self.data) > 4 else -1)    @property    def start_frame(self):        return int(self.data[5] if len(self.data) > 5 else -1)    @property    def label_action(self):        return int(self.data[6] if len(self.data) > 6 else -1)    def parse(self, dataset_info):        uid = self.uid        frame_count = self.num_frames        start_frame = self.start_frame if self.start_frame != -1 else 0        use_hands, use_gaze, use_objects, use_categories = False, False, False, False        hand_track_path, gaze_track_path, obj_track_path = None, None, None        if 'H' in dataset_info.td:            use_hands = True            path_d, path_ds, a, b, c, pid, vid_id = self.data_path.split("\\")  # os.path.sep            hand_track_path = os.path.join(path_d, path_ds, dataset_info.hand_list_prefix, pid, vid_id,                                           "{}_{}_{}.pkl".format(start_frame, self.label_verb, self.label_noun))        if 'O' in dataset_info.td:            use_objects = True            path_d, path_ds, a, b, c, pid, vid_id = self.data_path.split("\\")            obj_track_path = os.path.join(path_d, path_ds, dataset_info.object_list_prefix, pid, vid_id,                                          "{}_{}_{}.pkl".format(start_frame, self.label_verb, self.label_noun))        if 'C' in dataset_info.td:            use_categories = True            path_d, path_ds, a, b, c, pid, vid_id = self.data_path.split("\\")            obj_track_path = os.path.join(path_d, path_ds, dataset_info.object_list_prefix, pid, vid_id,                                          "{}_{}_{}.pkl".format(start_frame, self.label_verb, self.label_noun))        to_return = ((self.data_path, uid),                     (start_frame, frame_count),                     (use_hands, use_gaze, use_objects, use_categories),                     (hand_track_path, gaze_track_path, obj_track_path))        return to_returnclass GTEADataLine(DataLine):    def __init__(self, row):        super(GTEADataLine, self).__init__(row)        self.data_len = len(row)    @property    def frames_path(self):        path_parts = self.data[0].split("\\")        session_parts = path_parts[-1].split('-')        session = session_parts[0] + '-' + session_parts[1] + '-' + session_parts[2]        return os.path.join(path_parts[-4], path_parts[-3]), os.path.join(path_parts[-4], path_parts[-3],                                                                          path_parts[-2], session, path_parts[-1])    @property    def instance_name(self):        return self.data[0].split("\\")[-1]    @property    def label_action(self):  # to zero based labels        return int(self.data[1]) - 1    @property    def label_verb(self):        return int(self.data[2]) - 1    @property    def label_noun(self):        return int(self.data[3]) - 1    @property    def extra_nouns(self):        extra_nouns = list()        if self.data_len > 4:            for noun in self.data[4:]:                extra_nouns.append(int(noun) - 1)        return extra_nouns    def parse(self, dataset_info):        base_path, path = self.frames_path        instance_name = self.instance_name        uid = instance_name        frame_count = len(os.listdir(path))        assert frame_count > 0        use_hands, use_gaze, use_objects, use_categories = False, False, False, False        hand_track_path, gaze_track_path, obj_track_path = None, None, None        start_frame = 0        if 'H' in dataset_info.td:            use_hands = True            hand_track_path = os.path.join(base_path, dataset_info.hand_list_prefix, instance_name + '.pkl')        if 'G' in dataset_info.td:            use_gaze = True            gaze_track_path = os.path.join(base_path, dataset_info.gaze_list_prefix, instance_name + '.pkl')        to_return = ((path, uid),                     (start_frame, frame_count),                     (use_hands, use_gaze, use_objects, use_categories),                     (hand_track_path, gaze_track_path, obj_track_path))        return to_returnclass SOMETHINGV1DataLine(DataLine):    def __init__(self, row):        super(SOMETHINGV1DataLine, self).__init__(row)    @property    def uid(self):  # return as str not int        return self.data[0].split("\\")[-1]    @property    def label_action(self):        return self.data[1]    @property    def label_action_str(self):        action_str = ""        for d in self.data[1:]:            action_str += "{} ".format(d)        return action_str[:-1]    def parse(self, dataset_info):        start_frame = 1        frame_count = len(os.listdir(self.data_path))        assert frame_count > 0        use_hands, use_gaze, use_objects, use_categories = False, False, False, False        hand_track_path, gaze_track_path, obj_track_path = None, None, None        if 'H' in dataset_info.td:            use_hands = True            hand_track_path = os.path.join(self.data_path.replace("clips_frames", dataset_info.hand_list_prefix),                                           '.pkl')        to_return = ((self.data_path, self.uid),                     (start_frame, frame_count),                     (use_hands, use_gaze, use_objects, use_categories),                     (hand_track_path, gaze_track_path, obj_track_path))        return to_returnclass ADLDataLine(DataLine):    def __init__(self, row):        super(ADLDataLine, self).__init__(row)    @property    def num_frames(self):        return int(self.data[1])    @property    def uid(self):        return int(self.data[2])    @property    def start_frame(self):        return int(self.data[3])    @property    def label_action(self):        return int(self.data[4])    def label_location(self, sampled_idxs):        locations = self.data[5].strip('-').split('-')        loc_ids, loc_frames = [], []        for l in locations:            loc, fr = l.split(':')            loc_ids.append(int(loc))            loc_frames.append(int(fr))        if len(loc_ids) == 1:            return loc_ids[0]        elif len(loc_ids) == 0:            return 0  # undefined location        else:            max_num_before_change = -1            loc_id = -1            for i, frames in enumerate(loc_frames):                num_before_change = 0                for idx in sampled_idxs:                    if idx <= frames:                        num_before_change += 1                if num_before_change > max_num_before_change:                    max_num_before_change = num_before_change                    loc_id = i        return loc_ids[loc_id]    def parse(self, dataset_info):        frame_count = self.num_frames        start_frame = self.start_frame if self.start_frame != -1 else 0        use_hands, use_gaze, use_objects, use_categories = False, False, False, False        hand_track_path, gaze_track_path, obj_track_path = None, None, None        if 'H' in dataset_info.td:            use_hands = True            prefix = dataset_info.adl_hand_prefix            path_d, path_ds, adl_frames, pid = self.data_path.split("\\")            hand_track_path = os.path.join(path_d, path_ds, dataset_info.hand_list_prefix, '{}_{}.pkl'.format(prefix, self.uid))        to_return = ((self.data_path, self.uid),                     (start_frame, frame_count),                     (use_hands, use_gaze, use_objects, use_categories),                     (hand_track_path, gaze_track_path, obj_track_path))        return to_returnclass CHAREGODataLineBASE(DataLine):    def __init__(self, row):        super(CHAREGODataLineBASE, self).__init__(row)    @property    def num_frames(self):        return int(self.data[1])    @property    def label_location(self):        return int(self.data[4])    @property    def uid(self):        return self.data[5]    @property    def start_frame(self):  # to make frame ids 1-based        return int(self.data[6]) + 1    def parse(self, dataset_info):        frame_count = self.num_frames        start_frame = self.start_frame        use_hands, use_gaze, use_objects, use_categories = False, False, False, False        hand_track_path, gaze_track_path, obj_track_path = None, None, None        to_return = ((self.data_path, self.uid),                     (start_frame, frame_count),                     (use_hands, use_gaze, use_objects, use_categories),                     (hand_track_path, gaze_track_path, obj_track_path))        return to_returnclass CHAREGO1DataLineSample(CHAREGODataLineBASE):    def __init__(self, row):        super(CHAREGO1DataLineSample, self).__init__(row)    @property    def label_verb(self):        return int(self.data[2])    @property    def label_noun(self):        return int(self.data[3])    @property    def label_action(self):        return int(self.data[7])class CHAREGO3DataLineSample(CHAREGODataLineBASE):    def __init__(self, row):        super(CHAREGO3DataLineSample, self).__init__(row)    @property    def label_verb(self):        return int(self.data[2])    @property    def label_noun(self):        return int(self.data[3])    @property    def label_action(self):        return int(self.data[7])class CHAREGO1DataLineVideo(CHAREGODataLineBASE):    def __init__(self, row):        super(CHAREGO1DataLineVideo, self).__init__(row)    def strip_annotation_line(self, index):        annotations = list(set([int(x) for x in self.data[index].split('-')]))        return annotations    @property    def label_verb(self):        return self.strip_annotation_line(2)    @property    def label_noun(self):        return self.strip_annotation_line(3)    @property    def label_action(self):        return self.strip_annotation_line(7)class CHAREGO3DataLineVideo(CHAREGODataLineBASE):    def __init__(self, row):        super(CHAREGO3DataLineVideo, self).__init__(row)    def strip_annotation_line(self, index):        annotations = list(set([int(x) for x in self.data[index].split('-')]))        return annotations    @property    def label_verb(self):        return self.strip_annotation_line(2)    @property    def label_noun(self):        return self.strip_annotation_line(3)    @property    def label_action(self):        return self.strip_annotation_line(7)# def charegoDataLineConstructor(dataset_name, dataset_type):#     if dataset_type == 'sample':#         parent = CHAREGODataLineSample#     elif dataset_type == 'video':#         parent = CHAREGODataLineVideo#     else:#         raise Exception('Unknown dataset type for Charades')##     if dataset_name == 'charego1':#         # redefining the class does not work because the empty one is imported already#         # redefinition 1#         # CHAREGO1DataLine = type('CHAREGO1DataLine', (parent,), {'row': 'row'})#         # redefinition 2#         # class CHAREGO1DataLine(parent):#         #     def __init__(self, row):#         #         super(CHAREGO1DataLine, self).__init__(row)##         # returning the class type does not work either because isinstance sees a different class description#         # from the one already defined at the module level#         # return CHAREGO1DataLine##         # manually setting the base class worked#         CHAREGO1DataLine.__bases__ = (parent,)#     elif dataset_name == 'charego3':#         CHAREGO3DataLine.__bases__ = (parent,)## # for adding the desired parent I need to have the dummy definitions below to inherit from a custom class# # not from object# class CHAREGO1DataLine(CHAREGODataLineBASE):#     def __init__(self, row):#         super(CHAREGO1DataLine, self).__init__(row)## class CHAREGO3DataLine(CHAREGODataLineBASE):#     def __init__(self, row):#         super(CHAREGO3DataLine, self).__init__(row)